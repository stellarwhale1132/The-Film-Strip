<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Film Roll Memory v4 - Realistic Pull</title>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: 'Gaegu', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.8s ease;
            user-select: none; /* é˜²æ­¢é¸å–æ–‡å­—å¹²æ“¾æ‹–æ›³ */
        }

        body.projection-mode {
            background-color: #080808; 
        }

        header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        body.projection-mode header { opacity: 0.2; }
        body.projection-mode header:hover { opacity: 1; }

        .controls {
            display: inline-flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.85);
            padding: 10px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            align-items: center;
        }

        button, label {
            font-family: 'Gaegu', cursive;
            font-size: 1.1rem;
            padding: 5px 15px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            border-radius: 20px;
            color: #333;
            transition: transform 0.1s, background 0.2s;
        }
        
        button:active { transform: scale(0.95); }
        
        button.active {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
        }

        input[type="file"] { display: none; }
        
        .speed-box {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: #555;
            border-left: 1px solid #ccc;
            padding-left: 10px;
        }
        
        input[type="range"] {
            width: 80px;
            accent-color: #ff6b6b;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            cursor: grab;
            position: relative;
        }
        #canvas-container:active { cursor: grabbing; }

        .tip {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 1.5rem;
            pointer-events: none;
            text-shadow: 0 2px 5px rgba(255,255,255,0.5);
            transition: opacity 0.5s;
        }
        body.projection-mode .tip { color: #555; text-shadow: none; }
    </style>
</head>
<body>

    <header>
        <div class="controls">
            <label for="upload">ğŸ“· Load Photos</label>
            <input type="file" id="upload" multiple accept="image/*">
            
            <button id="toggleMode">ğŸ“½ï¸ Projection</button>
            <button id="adjustBtn">ğŸ–ï¸ Adjust</button>

            <div class="speed-box">
                <span>Speed:</span>
                <input type="range" id="speedSlider" min="1" max="15" value="4">
            </div>

            <button id="recordBtn">ğŸ”´ REC</button>
            <button id="resetBtn">â†º Reset</button>
        </div>
    </header>

    <div id="canvas-container">
        <canvas id="filmCanvas"></canvas>
    </div>

    <div class="tip" id="statusText">ä¸Šå‚³ç…§ç‰‡å¾Œï¼Œå‘å³æ‹‰å‹•åº•ç‰‡é ­ â”</div>

    <script>
        const canvas = document.getElementById('filmCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const statusText = document.getElementById('statusText');
        
        // --- æ ¸å¿ƒè®Šæ•¸ ---
        let imagesData = [];
        let isProjection = false;
        let isAdjustMode = false;
        
        // --- ç‰©ç†ä½ç½®è®Šæ•¸ ---
        // filmPullOffset: ä»£è¡¨åº•ç‰‡è¢«æ‹‰å‡ºä¾†äº†å¤šå°‘åƒç´ 
        // 0 = å®Œå…¨æ”¶åœ¨æ®¼è£¡ï¼ˆåªéœ²ä¸€é»é ­ï¼‰
        // æ•¸å€¼è¶Šå¤§ = æ‹‰å‡ºè¶Šå¤š
        let filmPullOffset = 0; 
        
        // äº’å‹•
        let isDragging = false;
        let lastX = 0;
        let startX = 0;
        
        // å‹•ç•«
        let isRecording = false;
        let autoScrollSpeed = 4;
        
        // --- å°ºå¯¸åƒæ•¸ ---
        const canisterX = 150; // åº•ç‰‡æ®¼ä¸­å¿ƒä½ç½® (è¢å¹•å·¦å´)
        const filmHeight = 320;
        const photoSize = 220;
        const gap = 35; 
        const padding = (filmHeight - photoSize) / 2;
        const leaderLength = 150; // ç‰‡é ­é•·åº¦
        
        // åˆå§‹åŒ–
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 1. ä¸Šå‚³
        document.getElementById('upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;
            
            imagesData = [];
            let loaded = 0;
            
            files.forEach(file => {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    const scale = Math.max(photoSize / img.width, photoSize / img.height);
                    imagesData.push({
                        img: img,
                        scale: scale,
                        x: (photoSize - img.width * scale) / 2,
                        y: (photoSize - img.height * scale) / 2
                    });
                    
                    loaded++;
                    if(loaded === files.length) {
                        filmPullOffset = 0; // é‡ç½®ç‚ºæ”¶èµ·ç‹€æ…‹
                        statusText.innerText = "æŠ“ä½åº•ç‰‡é ­ï¼Œå¾€å³æ‹‰ï¼ Pull Right â”";
                        draw();
                    }
                };
            });
        });

        // 2. é€Ÿåº¦
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            autoScrollSpeed = parseInt(e.target.value);
        });

        // ==========================================
        //        æ ¸å¿ƒç¹ªåœ– (Render)
        // ==========================================
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cy = canvas.height / 2; 
            const topY = cy - filmHeight / 2;
            
            // åº•ç‰‡å‡ºå£ä½ç½® (Slit Position)
            // è®“å®ƒç¨å¾®åœ¨æ®¼çš„å³é‚Šä¸€é»é»ï¼Œè£½é€ å¾ç¸«éš™å‡ºä¾†çš„éŒ¯è¦º
            const slitX = canisterX + 35; 

            // è¨ˆç®—è† æ²çš„å¯¦éš›ç¹ªè£½èµ·é»
            // æˆ‘å€‘ä»¥ slitX ç‚ºåŸºæº–é» (0é»)ã€‚
            // ç•¶ filmPullOffset = 0 æ™‚ï¼Œè† æ²é ­å‰›å¥½åœ¨ slitXã€‚
            // è† æ²çš„å…§å®¹å‘å·¦å»¶ä¼¸ (è² æ–¹å‘)ï¼Œæ‰€ä»¥æ‹‰å‹•æ™‚æˆ‘å€‘è¦å¹³ç§»ã€‚
            // ç‚ºäº†è®“é‚è¼¯ç°¡å–®ï¼šæˆ‘å€‘ç•«ä¸€æ¢å¾ˆé•·çš„è† æ²ï¼Œç„¶å¾Œåªé¡¯ç¤º slitX å³é‚Šçš„éƒ¨åˆ†ã€‚
            
            // çœŸæ­£è† æ²å…§å®¹çš„ X åº§æ¨™èµ·é» (Current Film Head Position)
            // ç•¶ offset å¢åŠ ï¼Œé€™å€‹é»å¾€å³è·‘
            const filmHeadX = slitX + filmPullOffset;

            // --- A. æŠ•å½±å±¤ (Projection) ---
            // åˆ¤æ–·å“ªå¼µç…§ç‰‡åœ¨ç•«é¢ä¸­é–“
            if (isProjection && imagesData.length > 0) {
                const screenCenter = canvas.width / 2;
                // é€†æ¨ï¼š(è¢å¹•ä¸­å¿ƒ - ç‰‡é ­ä½ç½®) / æ ¼å­å¯¬åº¦
                // æ¸›å»ç‰‡é ­é•·åº¦ï¼Œå› ç‚ºç…§ç‰‡æ˜¯æ¥åœ¨ç‰‡é ­å¾Œé¢çš„
                const distFromHead = screenCenter - (filmHeadX - leaderLength);
                const index = Math.floor(distFromHead / (photoSize + gap));
                
                if (index >= 0 && index < imagesData.length) {
                    // åªæœ‰ç•¶é€™å¼µç…§ç‰‡çœŸçš„è¢«æ‹‰å‡ºä¾†(éäº† Slit)æ‰æŠ•å½±
                    // ç°¡å–®åˆ¤æ–·ï¼šfilmPullOffset è¶³å¤ å¤§
                    const photoRealX = filmHeadX - leaderLength - (index+1)*(photoSize+gap) + photoSize; // ç²—ç•¥ä¼°ç®—
                    
                    // ç¹ªè£½èƒŒæ™¯
                    const bgImg = imagesData[index].img;
                    ctx.save();
                    ctx.filter = 'blur(25px) brightness(0.5)';
                    const bgScale = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
                    const bw = bgImg.width * bgScale;
                    const bh = bgImg.height * bgScale;
                    ctx.drawImage(bgImg, (canvas.width-bw)/2, (canvas.height-bh)/2, bw, bh);
                    
                    // æ‰“å…‰æ•ˆæœ
                    ctx.filter = 'none';
                    const gradient = ctx.createLinearGradient(0, canvas.height, 0, cy);
                    gradient.addColorStop(0, "rgba(255, 255, 255, 0.3)");
                    gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                    ctx.fillStyle = gradient;
                    ctx.globalCompositeOperation = 'overlay';
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.lineTo(canvas.width*0.7, cy);
                    ctx.lineTo(canvas.width*0.3, cy);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // --- B. è† æ²å±¤ (The Film Strip) ---
            ctx.save();
            
            // *** é—œéµ 1: é®ç½© (Clipping Mask) ***
            // å®šç¾©ä¸€å€‹çŸ©å½¢å€åŸŸï¼šå¾åº•ç‰‡æ®¼ç¸«éš™(slitX)ä¸€ç›´åˆ°è¢å¹•æœ€å³é‚Šã€‚
            // æ‰€æœ‰ç•«åœ¨é€™å€‹å€åŸŸä»¥å¤–çš„æ±è¥¿(ä¹Ÿå°±æ˜¯æ®¼çš„å·¦é‚Š/è£¡é¢)éƒ½æœƒéš±å½¢ã€‚
            ctx.beginPath();
            ctx.rect(slitX, 0, canvas.width - slitX, canvas.height);
            ctx.clip(); // å•Ÿå‹•é®ç½©

            // ç§»å‹•åº§æ¨™ç³»ï¼Œè®“ (0,0) è®Šæˆè† æ²é ­ç›®å‰çš„ä½ç½®
            ctx.translate(filmHeadX, topY);

            // ç¸½é•·åº¦è¨ˆç®—
            const totalContentWidth = imagesData.length * (photoSize + gap) + gap;

            // 1. ç•«ç‰‡é ­ (Leader) - åœ¨ 0 çš„å·¦é‚Š
            // å½¢ç‹€ï¼šåœ“è§’æ¢¯å½¢
            ctx.fillStyle = "#111";
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(-leaderLength, 40); // èˆŒé ­å°–ç«¯ç¸®çª„
            ctx.lineTo(-leaderLength, filmHeight - 40);
            ctx.lineTo(0, filmHeight);
            ctx.fill();
            // å¯«ä¸Šæ–‡å­—
            ctx.fillStyle = "#fff";
            ctx.font = "20px Gaegu";
            ctx.fillText("PULL HERE", -leaderLength + 20, filmHeight/2);

            // 2. ç•«ä¸»è¦è† æ²åº•è‰² (å¾€å·¦å»¶ä¼¸ï¼Œå› ç‚ºæ˜¯æ‹‰å‡ºä¾†çš„)
            // åº§æ¨™ç³»ç¾åœ¨åœ¨è† æ²é ­ï¼Œç…§ç‰‡åœ¨é ­çš„ã€Œå¾Œé¢ã€(å·¦é‚Š)ï¼Ÿ
            // ä¸å°ï¼Œæˆ‘å€‘æ˜¯æŠŠè† æ²å¾€å³æ‹‰ã€‚
            // [Photo 2] [Photo 1] [Leader] ---> æ‹‰å‘å³é‚Š
            // æ‰€ä»¥ Photo 1 çš„ x æ‡‰è©²æ˜¯è² çš„ï¼Ÿ
            // è®“æˆ‘å€‘ä¿®æ­£é‚è¼¯ï¼š
            // filmHeadX æ˜¯æœ€å³ç«¯ã€‚ç…§ç‰‡ä¾åºæ’åœ¨å·¦é‚Šã€‚
            // index 0 (Photo 1) closest to leader.
            
            // è† æ²é»‘è‰²é•·æ¢
            ctx.fillStyle = isProjection ? "rgba(10,10,10,0.9)" : "#151515";
            ctx.fillRect(-totalContentWidth, 0, totalContentWidth, filmHeight);

            // 3. ç•«é½’å­” (Sprockets)
            ctx.fillStyle = "#eee";
            const numHoles = Math.floor(totalContentWidth / 30);
            for(let k=0; k<numHoles; k++) {
                // å¾é ­å¾€å›ç•«
                const hx = -(k * 30 + 15); 
                roundRect(ctx, hx, 15, 18, 12, 2, true, false);
                roundRect(ctx, hx, filmHeight - 27, 18, 12, 2, true, false);
            }

            // 4. ç•«ç…§ç‰‡
            imagesData.forEach((data, i) => {
                // ä½ç½®ï¼šå¾é ­å¾€å·¦ç®— (è² å€¼)
                // Leader | gap | Photo 1 | gap | Photo 2 ...
                const x = - ( (i+1) * (photoSize + gap) ); 
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, padding, photoSize, photoSize);
                ctx.clip();

                if(isProjection) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.9;
                }

                const w = data.img.width * data.scale;
                const h = data.img.height * data.scale;
                ctx.drawImage(data.img, x + data.x, padding + data.y, w, h);

                // ç´…æ¡†
                if(isAdjustMode) {
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, padding, photoSize, photoSize);
                }
                ctx.restore();

                // è™Ÿç¢¼
                if(!isProjection) {
                    ctx.fillStyle = "orange";
                    ctx.font = "bold 16px Arial";
                    ctx.fillText(`${i+1}`, x + photoSize/2, filmHeight - 8);
                }
            });

            ctx.restore(); // çµæŸé®ç½©èˆ‡è† æ²ç¹ªè£½

            // --- C. åº•ç‰‡æ®¼ (Canister) ---
            // ç•«åœ¨æœ€ä¸Šå±¤ï¼Œé®ä½å·¦é‚Šè¢« clip æ‰çš„é‚Šç·£ï¼Œè£½é€ å®Œç¾å‡ºç‰‡æ„Ÿ
            drawCanister(canisterX, cy);

            if(imagesData.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "24px Gaegu";
                ctx.fillText("Waiting...", canisterX + 60, cy);
            }
        }

        // ç¹ªè£½ç²¾ç·»åº•ç‰‡æ®¼
        function drawCanister(cx, cy) {
            const w = 80;
            const h = filmHeight + 30;
            const top = cy - h/2;
            
            ctx.save();
            ctx.shadowColor = "rgba(0,0,0,0.4)";
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 5;

            // 1. é‡‘å±¬åœ“æŸ±æ¼¸å±¤
            const grad = ctx.createLinearGradient(cx-w/2, 0, cx+w/2, 0);
            grad.addColorStop(0, "#D4AF37");
            grad.addColorStop(0.3, "#FFD700");
            grad.addColorStop(0.6, "#FFF8DC");
            grad.addColorStop(1, "#DAA520");
            
            ctx.fillStyle = grad;
            ctx.fillRect(cx - w/2, top, w, h);

            // 2. å‡ºç‰‡ç¸«éš™ (Slit) - åŠ ä¸Šé™°å½±è®“å®ƒçœ‹èµ·ä¾†æœ‰æ·±åº¦
            ctx.fillStyle = "#000";
            ctx.fillRect(cx + w/2 - 6, top + 10, 6, h - 20);
            
            // 3. è“‹å­
            ctx.fillStyle = "#222";
            // ä¸Šè“‹
            ctx.beginPath();
            ctx.ellipse(cx, top, w/2, 10, 0, 0, Math.PI*2);
            ctx.fill();
            // ä¸‹è“‹
            ctx.beginPath();
            ctx.ellipse(cx, top+h, w/2, 10, 0, 0, Math.PI*2);
            ctx.fill();
            
            // 4. LOGO
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-Math.PI/2);
            ctx.fillStyle = "#000";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("FILM ROLL", 0, 5);
            ctx.restore();

            ctx.restore();
        }

        // 3. äº’å‹•é‚è¼¯ (ä¿®æ­£æ–¹å‘)
        container.addEventListener('mousedown', e => startDrag(e.clientX));
        container.addEventListener('touchstart', e => startDrag(e.touches[0].clientX));

        window.addEventListener('mousemove', e => onDrag(e.clientX, e.clientY)); // éœ€è¦ Y for adjust
        window.addEventListener('touchmove', e => onDrag(e.touches[0].clientX, e.touches[0].clientY));

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        function startDrag(x) {
            if(isRecording) return;
            isDragging = true;
            lastX = x;
            container.style.cursor = "grabbing";
        }

        function onDrag(x, y) {
            if (!isDragging) return;
            
            // è¨ˆç®—æ°´å¹³ç§»å‹•é‡
            const dx = x - lastX;
            
            if (isAdjustMode) {
                // èª¿æ•´ç…§ç‰‡ (é‚è¼¯è¼ƒè¤‡é›œï¼Œéœ€åç®—ä½ç½®)
                // æš«æ™‚ç°¡åŒ–ï¼šåªèª¿æ•´ç›®å‰ç•«é¢ä¸­æœ€æ˜é¡¯çš„é‚£å¼µ
                // é€™è£¡ç•¥éè¤‡é›œç¢°æ’æª¢æ¸¬ï¼Œå°ˆæ³¨æ–¼è† æ²æ‹‰å‹•
            } else {
                // *** é—œéµç‰©ç†ï¼šæ‹‰å‹•è† æ² ***
                // å¾€å³æ‹‰ (dx > 0) -> offset å¢åŠ  (æ‹‰å‡ºä¾†)
                // å¾€å·¦æ‹‰ (dx < 0) -> offset æ¸›å°‘ (æ”¶å›å»)
                filmPullOffset += dx;

                // é™åˆ¶ï¼šä¸èƒ½æ¨å›æ®¼è£¡å¤ªæ·± (æœ€å° 0)
                if (filmPullOffset < 0) filmPullOffset = 0;
                
                // é™åˆ¶ï¼šä¸èƒ½æ‹‰åˆ°è„«è½ (è¨­ä¸€å€‹æœ€å¤§å€¼)
                const maxPull = imagesData.length * (photoSize + gap) + 500;
                if (filmPullOffset > maxPull) filmPullOffset = maxPull;
            }
            
            lastX = x;
            draw();
        }

        function endDrag() {
            isDragging = false;
            container.style.cursor = "grab";
        }

        // 4. æŒ‰éˆ•åŠŸèƒ½
        const adjustBtn = document.getElementById('adjustBtn');
        adjustBtn.addEventListener('click', () => {
            isAdjustMode = !isAdjustMode;
            adjustBtn.classList.toggle('active');
            statusText.innerText = isAdjustMode ? "Editing Mode" : "Pull Right â”";
            draw();
        });

        document.getElementById('toggleMode').addEventListener('click', () => {
            isProjection = !isProjection;
            document.body.classList.toggle('projection-mode');
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            filmPullOffset = 0;
            draw();
        });

        // 5. éŒ„è£½ (è‡ªå‹•å¾€å³æ‹‰)
        const recordBtn = document.getElementById('recordBtn');
        recordBtn.addEventListener('click', () => {
            if(imagesData.length === 0) return alert("No photos!");
            if(isRecording) return;
            
            isRecording = true;
            recordBtn.classList.add('active');
            recordBtn.innerText = "Recording...";
            
            // é–‹å§‹éŒ„è£½
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory_roll_${Date.now()}.webm`;
                a.click();
                isRecording = false;
                recordBtn.innerText = "ğŸ”´ REC";
                recordBtn.classList.remove('active');
            };
            recorder.start();

            // é‡ç½®åˆ°èµ·é»
            filmPullOffset = 0;
            
            // å‹•ç•«è¿´åœˆ
            const maxLen = imagesData.length * (photoSize + gap) + canvas.width;

            function animate() {
                if(!isRecording) return;
                
                filmPullOffset += autoScrollSpeed; // è‡ªå‹•å¾€å³æ‹‰
                draw();
                
                if(filmPullOffset < maxLen) {
                    requestAnimationFrame(animate);
                } else {
                    recorder.stop();
                }
            }
            animate();
        });

        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (stroke) ctx.stroke();
            if (fill) ctx.fill();
        }
    </script>
</body>
</html>
