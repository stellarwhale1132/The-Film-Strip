<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Film Memory v3 - Cinema Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            font-family: 'Gaegu', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            transition: background-color 1s ease;
        }

        /* æŠ•å½±æ¨¡å¼ä¸‹çš„èƒŒæ™¯ - æ·±è‰²æš—æˆ¿ */
        body.projection-mode {
            background-color: #050505; 
        }

        header {
            position: absolute;
            top: 20px;
            text-align: center;
            z-index: 100;
            width: 100%;
            pointer-events: none; /* è®“é»æ“Šå¯ä»¥ç©¿é€åˆ° Canvas */
            transition: opacity 0.5s;
        }

        body.projection-mode header {
            opacity: 0.2; /* æŠ•å½±æ™‚æ·¡åŒ–ä»‹é¢ */
        }
        
        /* æ»‘é¼ ç§»ä¸Šå»æ™‚é¡¯ç¤ºä»‹é¢ */
        body.projection-mode header:hover {
            opacity: 1;
        }

        .controls {
            pointer-events: auto;
            display: inline-flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 40px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }

        button, label {
            font-family: 'Gaegu', cursive;
            font-size: 1.1rem;
            padding: 5px 15px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            border-radius: 20px;
            color: #333;
            transition: all 0.2s;
            font-weight: bold;
        }

        button:hover, label:hover {
            background: #ffe082;
            transform: scale(1.05);
        }
        
        button.active {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
        }

        input[type="file"] { display: none; }

        /* é€Ÿåº¦æ§åˆ¶æ¢æ¨£å¼ */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1rem;
            color: #555;
            border: 2px solid #ddd;
            padding: 5px 10px;
            border-radius: 20px;
        }
        
        input[type="range"] {
            width: 100px;
            accent-color: #ff6b6b;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }
        #canvas-container.editing-mode { cursor: move; }

        .tip {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 1.2rem;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>

    <header>
        <div class="controls">
            <label for="upload">ğŸ“· ä¸Šå‚³ç…§ç‰‡</label>
            <input type="file" id="upload" multiple accept="image/*">
            
            <button id="adjustBtn">ğŸ–ï¸ èª¿æ•´ä½ç½®</button>
            <button id="toggleMode">ğŸ“½ï¸ æŠ•å½±æ¨¡å¼</button>
            
            <div class="speed-control">
                <span>é€Ÿåº¦:</span>
                <input type="range" id="speedSlider" min="1" max="20" value="3">
            </div>

            <button id="recordBtn">ğŸ”´ éŒ„è£½å½±ç‰‡</button>
            <button id="resetBtn">â†º</button>
        </div>
    </header>

    <div id="canvas-container">
        <canvas id="filmCanvas"></canvas>
    </div>
    
    <div class="tip" id="statusText">è«‹ä¸Šå‚³ç…§ç‰‡ / Please Upload Photos</div>

    <script>
        const canvas = document.getElementById('filmCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const statusText = document.getElementById('statusText');
        
        // --- æ ¸å¿ƒè®Šæ•¸ ---
        let imagesData = [];
        let isProjection = false;
        let isAdjustMode = false;
        
        // äº’å‹•èˆ‡ä½ç½®
        let filmOffsetX = 250; // è† æ²èµ·å§‹ä½ç½® (å¾æ®¼å£å‡ºä¾†)
        let isDragging = false;
        let lastX = 0, lastY = 0;
        
        // å‹•ç•«/éŒ„å½±æ§åˆ¶
        let animationId = null;
        let isRecording = false;
        let autoScrollSpeed = 3;
        
        // --- å¤–è§€åƒæ•¸ ---
        const filmY = window.innerHeight / 2; // å‚ç›´ç½®ä¸­
        const filmHeight = 320;
        const photoSize = 220; // ç…§ç‰‡æ ¼å¤§å°
        const gap = 35; // ç…§ç‰‡é–“è·
        const padding = (filmHeight - photoSize) / 2;
        const canisterWidth = 90; // åº•ç‰‡æ®¼å¯¬åº¦
        
        // åˆå§‹åŒ– Canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 1. ä¸Šå‚³è™•ç†
        document.getElementById('upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;
            
            // ä¿æŒç¾æœ‰ç…§ç‰‡ï¼Œè¿½åŠ æ–°çš„ (æˆ–è€…é‡ç½®ï¼Œé€™è£¡é¸æ“‡é‡ç½®)
            imagesData = []; 
            let loaded = 0;
            
            files.forEach(file => {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    // Cover æ¨¡å¼æ¯”ä¾‹è¨ˆç®—
                    const scale = Math.max(photoSize / img.width, photoSize / img.height);
                    imagesData.push({
                        img: img,
                        scale: scale,
                        x: (photoSize - img.width * scale) / 2,
                        y: (photoSize - img.height * scale) / 2
                    });
                    
                    loaded++;
                    if(loaded === files.length) {
                        filmOffsetX = 250; 
                        statusText.innerText = "å·¦å³æ‹–æ›³è† æ² / Drag to scroll";
                        draw();
                    }
                };
            });
        });

        // 2. é€Ÿåº¦æ§åˆ¶
        const speedSlider = document.getElementById('speedSlider');
        speedSlider.addEventListener('input', (e) => {
            autoScrollSpeed = parseInt(e.target.value);
        });

        // ==========================================
        //        æ ¸å¿ƒç¹ªåœ–å¼•æ“ (Render Engine)
        // ==========================================
        function draw() {
            // æ¸…ç©ºç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // å‚ç›´ç½®ä¸­åƒæ•¸
            const cy = canvas.height / 2; 
            const topY = cy - filmHeight / 2;

            // è¨ˆç®—ç›®å‰å“ªå¼µç…§ç‰‡åœ¨ç•«é¢æ­£ä¸­å¤® (ç”¨æ–¼æŠ•å½±)
            let centerIndex = -1;
            if (imagesData.length > 0) {
                // ç®—æ³•ï¼š(è¢å¹•ä¸­å¿ƒ - è† æ²åç§») / å–®æ ¼å¯¬åº¦
                const screenCenter = canvas.width / 2;
                // ç¨å¾®ä¿®æ­£ 250 æ˜¯åº•ç‰‡æ®¼åç§»
                centerIndex = Math.floor((screenCenter - filmOffsetX) / (photoSize + gap));
                // é‚Šç•Œæª¢æŸ¥
                if (centerIndex < 0) centerIndex = 0;
                if (centerIndex >= imagesData.length) centerIndex = imagesData.length - 1;
            }

            // --- A. èƒŒæ™¯æŠ•å½±å±¤ (Background Projection) ---
            if (isProjection && centerIndex !== -1 && imagesData[centerIndex]) {
                const bgImg = imagesData[centerIndex].img;
                
                ctx.save();
                // 1. ç¹ªè£½å…¨ç‰ˆèƒŒæ™¯æ¨¡ç³Šåœ–
                ctx.filter = 'blur(20px) brightness(0.4)';
                // ä¿æŒæ¯”ä¾‹å¡«æ»¿èƒŒæ™¯
                const bgScale = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
                const bw = bgImg.width * bgScale;
                const bh = bgImg.height * bgScale;
                const bx = (canvas.width - bw) / 2;
                const by = (canvas.height - bh) / 2;
                ctx.drawImage(bgImg, bx, by, bw, bh);

                // 2. ç¹ªè£½åº•éƒ¨æ‰“å…‰æ•ˆæœ (Light Beam)
                ctx.filter = 'none'; // é—œé–‰æ¿¾é¡ç•«æ¼¸å±¤
                const gradient = ctx.createLinearGradient(0, canvas.height, 0, cy);
                gradient.addColorStop(0, "rgba(255, 255, 255, 0.4)"); // åº•éƒ¨å…‰äº®
                gradient.addColorStop(1, "rgba(255, 255, 255, 0)");   // é ‚éƒ¨é€æ˜
                
                ctx.globalCompositeOperation = 'overlay';
                ctx.fillStyle = gradient;
                // ç•«æ¢¯å½¢å…‰æŸ
                ctx.beginPath();
                ctx.moveTo(canvas.width * 0.2, canvas.height);
                ctx.lineTo(canvas.width * 0.8, canvas.height);
                ctx.lineTo(canvas.width * 0.6, cy);
                ctx.lineTo(canvas.width * 0.4, cy);
                ctx.fill();
                
                ctx.restore();
            }

            // --- B. è† æ²åœ–å±¤ (Film Strip) ---
            // å„²å­˜ç‹€æ…‹ï¼Œæº–å‚™ç§»å‹•åº§æ¨™
            ctx.save();
            ctx.translate(filmOffsetX, topY);

            const totalWidth = imagesData.length * (photoSize + gap) + gap + 100;

            // 1. è† æ²é»‘åº•
            ctx.fillStyle = "#151515";
            // ç•«é•·æ¢ï¼Œå·¦é‚Šç¨å¾®å»¶ä¼¸é€²åº•ç‰‡æ®¼
            roundRect(ctx, -20, 0, totalWidth, filmHeight, 2, true, false);

            // 2. é½’å­” (Sprockets)
            ctx.fillStyle = "#e0e0e0";
            const numHoles = Math.floor(totalWidth / 30);
            for (let k = 0; k < numHoles; k++) {
                const hx = k * 30 - 10;
                // åªæœ‰ç•¶é½’å­”åœ¨åº•ç‰‡æ®¼å³é‚Šæ‰ç•« (æ¨¡æ“¬å¾æ®¼è£¡å‡ºä¾†)
                // åº•ç‰‡æ®¼å£å¤§ç´„åœ¨ x=0 çš„ä½ç½® (å› ç‚ºæˆ‘å€‘ translate äº†)
                if (filmOffsetX + hx > 220) { 
                     // é€™è£¡çš„é‚è¼¯æ˜¯: çµ•å°ä½ç½® > æ®¼çš„å³ç·£
                     // ç°¡åŒ–: ç•«å…¨éƒ¨ï¼Œæœ€å¾Œç”¨æ®¼è“‹ä½
                }
                roundRect(ctx, hx, 15, 18, 12, 2, true, false);
                roundRect(ctx, hx, filmHeight - 27, 18, 12, 2, true, false);
            }

            // 3. ç…§ç‰‡å…§å®¹
            imagesData.forEach((data, i) => {
                const x = i * (photoSize + gap) + 50;
                
                ctx.save();
                
                // è£åˆ‡æ¡†
                ctx.beginPath();
                ctx.rect(x, padding, photoSize, photoSize);
                ctx.clip();

                // æŠ•å½±æ¨¡å¼ï¼šç…§ç‰‡æœ¬é«”ç¨å¾®è®Šäº®
                if (isProjection) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.9;
                }

                const w = data.img.width * data.scale;
                const h = data.img.height * data.scale;
                ctx.drawImage(data.img, x + data.x, padding + data.y, w, h);

                // ç´…è‰²èª¿æ•´æ¡†
                if (isAdjustMode) {
                    ctx.strokeStyle = "#ff3333";
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, padding, photoSize, photoSize);
                }

                ctx.restore();

                // æ–‡å­—
                if(!isProjection) {
                    ctx.fillStyle = "#888";
                    ctx.font = "14px Arial";
                    ctx.fillText(`${i+1}A`, x + photoSize/2, filmHeight - 8);
                }
            });

            ctx.restore(); // æ¢å¾©åº§æ¨™ç³»ï¼ŒçµæŸè† æ²ç¹ªè£½

            // --- C. åº•ç‰‡æ®¼åœ–å±¤ (The Canister) - æ°¸é è“‹åœ¨æœ€ä¸Šé¢ ---
            // ä½ç½®å›ºå®šåœ¨ç•«é¢å·¦å´
            drawRealisticCanister(120, cy); 
            
            // å¦‚æœæ²’ç…§ç‰‡
            if(imagesData.length === 0) {
                ctx.fillStyle = isProjection ? "#666" : "#aaa";
                ctx.font = "30px Gaegu";
                ctx.textAlign = "center";
                ctx.fillText("Waiting for film...", canvas.width/2 + 100, cy);
            }
        }

        // --- ç¹ªè£½ç«‹é«”åº•ç‰‡æ®¼ ---
        function drawRealisticCanister(cx, cy) {
            const w = canisterWidth;
            const h = filmHeight + 40;
            const topY = cy - h/2;
            
            ctx.save();
            
            // é™°å½± (è®“å®ƒçœ‹èµ·ä¾†æµ®åœ¨åº•ç‰‡ä¸Š)
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 10;

            // 1. æ®¼èº«æ¼¸å±¤ (é‡‘å±¬é»ƒè³ªæ„Ÿ)
            const grad = ctx.createLinearGradient(cx - w/2, 0, cx + w/2, 0);
            grad.addColorStop(0, "#b8860b"); // æš—é‡‘
            grad.addColorStop(0.2, "#f1c40f"); // äº®é»ƒ
            grad.addColorStop(0.5, "#fcd670"); // é«˜å…‰
            grad.addColorStop(0.8, "#f1c40f");
            grad.addColorStop(1, "#b8860b");

            // ç•«åœ“æŸ±é«”
            ctx.fillStyle = grad;
            ctx.fillRect(cx - w/2, topY, w, h);

            // 2. æ¨™ç±¤ (é»‘è‰²çŸ©å½¢)
            ctx.fillStyle = "#111";
            ctx.fillRect(cx - w/2 + 5, topY + 40, w - 10, h - 80);

            // 3. ä¸Šä¸‹è“‹ (é»‘è‰²å¡‘è† è³ªæ„Ÿ)
            ctx.fillStyle = "#222";
            
            // ä¸Šè“‹
            ctx.beginPath();
            ctx.ellipse(cx, topY, w/2, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // ä¸Šè“‹å‡¸èµ·
            const knobGrad = ctx.createLinearGradient(cx-15, 0, cx+15, 0);
            knobGrad.addColorStop(0, "#444");
            knobGrad.addColorStop(0.5, "#888"); // é‡‘å±¬åå…‰
            knobGrad.addColorStop(1, "#444");
            ctx.fillStyle = knobGrad;
            ctx.beginPath();
            ctx.rect(cx - 10, topY - 15, 20, 15);
            ctx.fill();

            // ä¸‹è“‹
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.ellipse(cx, topY + h, w/2, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // 4. å‡ºç‰‡å£ (Slit) - é—œéµçš„è¦–è¦ºç´°ç¯€
            // åœ¨å³å´ç•«ä¸€å€‹é»‘è‰²çš„ç´°é•·æ¢ï¼Œæ¨¡æ“¬åº•ç‰‡å‡ºä¾†çš„åœ°æ–¹
            ctx.fillStyle = "#000";
            ctx.fillRect(cx + w/2 - 5, cy - filmHeight/2 - 2, 8, filmHeight + 4);

            // 5. æ¨™ç±¤æ–‡å­—
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-Math.PI / 2); // è½‰90åº¦
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "#f1c40f";
            ctx.textAlign = "center";
            ctx.fillText("MEMORIES 400", 0, 8);
            ctx.restore();

            ctx.restore();
        }

        // 3. äº’å‹•é‚è¼¯
        container.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
        container.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY));

        window.addEventListener('mousemove', e => onDrag(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => onDrag(e.touches[0].clientX, e.touches[0].clientY));

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        function startDrag(x, y) {
            if(isRecording) return; // éŒ„å½±ä¸­ç¦æ­¢æ‰‹å‹•å¹²æ“¾
            isDragging = true;
            lastX = x;
            lastY = y;
            container.style.cursor = isAdjustMode ? "grabbing" : "grabbing";
        }

        function onDrag(x, y) {
            if (!isDragging) return;
            const dx = x - lastX;
            const dy = y - lastY;
            lastX = x;
            lastY = y;

            if (isAdjustMode) {
                // èª¿æ•´ç…§ç‰‡ä½ç½®
                const relativeX = x - filmOffsetX; 
                const index = Math.floor((relativeX - 50) / (photoSize + gap));
                if (index >= 0 && index < imagesData.length) {
                    imagesData[index].x += dx;
                    imagesData[index].y += dy;
                }
            } else {
                // æ‹–æ›³è† æ²
                filmOffsetX += dx;
                // é™åˆ¶æœ€å·¦é‚Š (ä¸èƒ½æŠŠè† æ²å°¾å·´éƒ½æ‹‰å‡ºä¾†)
                if (filmOffsetX > 250) filmOffsetX = 250;
            }
            draw();
        }

        function endDrag() {
            isDragging = false;
            container.style.cursor = isAdjustMode ? "move" : "grab";
        }

        // 4. æŒ‰éˆ•åŠŸèƒ½
        const adjustBtn = document.getElementById('adjustBtn');
        adjustBtn.addEventListener('click', () => {
            isAdjustMode = !isAdjustMode;
            adjustBtn.classList.toggle('active');
            container.classList.toggle('editing-mode');
            statusText.innerText = isAdjustMode ? 
                "æŒ‰ä½ç…§ç‰‡ç§»å‹•èª¿æ•´ / Drag photo to adjust" : 
                "å·¦å³æ‹–æ›³è† æ² / Drag to scroll";
            draw();
        });

        document.getElementById('toggleMode').addEventListener('click', () => {
            isProjection = !isProjection;
            document.body.classList.toggle('projection-mode');
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            filmOffsetX = 250;
            draw();
        });

        // 5. éŒ„è£½èˆ‡è‡ªå‹•æ’­æ”¾
        const recordBtn = document.getElementById('recordBtn');
        recordBtn.addEventListener('click', () => {
            if(imagesData.length === 0) return alert("è«‹å…ˆä¸Šå‚³ç…§ç‰‡ï¼");
            
            if(isRecording) return; // é¿å…é‡è¤‡é»æ“Š
            isRecording = true;
            recordBtn.innerText = "éŒ„è£½ä¸­...";
            recordBtn.classList.add('active');

            // æº–å‚™éŒ„è£½
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];
            
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cinema_film_${Date.now()}.webm`;
                a.click();
                
                isRecording = false;
                recordBtn.innerText = "ğŸ”´ éŒ„è£½å½±ç‰‡";
                recordBtn.classList.remove('active');
                alert("éŒ„è£½å®Œæˆï¼");
            };

            recorder.start();

            // é‡ç½®ä½ç½®
            filmOffsetX = 250;
            
            // è¨ˆç®—çµ‚é»
            const endX = -(imagesData.length * (photoSize + gap)) + canvas.width/2;

            function animate() {
                if (!isRecording) return;

                // ä½¿ç”¨ä½¿ç”¨è€…è¨­å®šçš„é€Ÿåº¦
                filmOffsetX -= autoScrollSpeed; 
                draw();

                if (filmOffsetX > endX) {
                    requestAnimationFrame(animate);
                } else {
                    recorder.stop();
                }
            }
            animate();
        });

        // è¼”åŠ©å‡½å¼
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (stroke) ctx.stroke();
            if (fill) ctx.fill();
        }
    </script>
</body>
</html>
