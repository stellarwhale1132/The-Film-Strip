<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Film Roll Memory v2</title>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f0; /* æ˜äº®èƒŒæ™¯ */
            font-family: 'Gaegu', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.8s ease;
        }

        /* æŠ•å½±æ¨¡å¼ï¼šæš—æˆ¿é¢¨æ ¼ */
        body.projection-mode {
            background-color: #111; 
        }

        header {
            margin-top: 15px;
            text-align: center;
            z-index: 10;
            transition: opacity 0.3s;
        }
        
        /* æŠ•å½±æ¨¡å¼ä¸‹éš±è—æ¨™é¡Œï¼Œå°ˆæ³¨çœ‹ç…§ç‰‡ */
        body.projection-mode header {
            opacity: 0.3; 
        }

        h1 {
            color: #555;
            margin: 0 0 10px 0;
            transition: color 0.5s;
        }
        
        body.projection-mode h1 { color: #888; }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        button, label {
            font-family: 'Gaegu', cursive;
            font-size: 1.1rem;
            padding: 6px 12px;
            border: 2px solid #444;
            background: white;
            cursor: pointer;
            border-radius: 15px;
            color: #333;
            transition: all 0.2s;
            user-select: none;
        }

        button:hover, label:hover {
            background: #ffeb3b;
            transform: translateY(-2px);
        }

        button.active {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
        }

        input[type="file"] { display: none; }

        #canvas-container {
            flex-grow: 1;
            width: 100%;
            position: relative;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas-container:active { cursor: grabbing; }
        
        /* èª¿æ•´æ¨¡å¼ä¸‹çš„æ¸¸æ¨™ */
        #canvas-container.editing-mode { cursor: move; }

        .tip {
            position: absolute;
            bottom: 20px;
            color: #888;
            font-size: 1rem;
            pointer-events: none;
            transition: color 0.5s;
        }
        body.projection-mode .tip { color: #444; }
    </style>
</head>
<body>

    <header>
        <h1>My Film Roll v2 ğŸï¸</h1>
        <div class="controls">
            <label for="upload">ğŸ“· 1. ä¸Šå‚³ (Upload)</label>
            <input type="file" id="upload" multiple accept="image/*">
            
            <button id="adjustBtn">ğŸ–ï¸ 2. èª¿æ•´ç›¸ç‰‡ä½ç½® (Move Photo)</button>
            <button id="toggleMode">âœ¨ 3. æŠ•å½±æ¨¡å¼ (Project)</button>
            <button id="recordBtn">ğŸ¥ 4. åŒ¯å‡ºå½±ç‰‡ (Export)</button>
            <button id="resetBtn">â†º é‡ç½® (Reset)</button>
        </div>
    </header>

    <div id="canvas-container">
        <canvas id="filmCanvas"></canvas>
    </div>

    <div class="tip" id="statusText">æ‹–æ›³è† æ² / Drag film strip</div>

    <script>
        const canvas = document.getElementById('filmCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const statusText = document.getElementById('statusText');
        
        // ç‹€æ…‹è®Šæ•¸
        let imagesData = []; // çµæ§‹: { img: Image, x: 0, y: 0, scale: 1 }
        let isProjection = false;
        let isAdjustMode = false;
        
        // äº’å‹•è®Šæ•¸
        let filmOffsetX = 200; // è† æ²æ•´é«”ä½ç½® (èµ·å§‹é»è¨­åœ¨åº•ç‰‡æ®¼å³é‚Š)
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // åƒæ•¸è¨­å®š
        const filmY = 100; // è† æ²å‚ç›´ä½ç½®
        const filmHeight = 360;
        const photoSize = 250;
        const gap = 30; 
        const padding = (filmHeight - photoSize) / 2; // ä¸Šä¸‹é»‘é‚Šå¯¬åº¦
        
        // åˆå§‹åŒ–
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.8; // ä½”æ“š 80% é«˜åº¦
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 1. ä¸Šå‚³è™•ç†
        document.getElementById('upload').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;
            
            imagesData = []; // æ¸…ç©ºèˆŠåœ–
            let loaded = 0;
            
            files.forEach(file => {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    // è¨ˆç®—åˆå§‹ç¸®æ”¾æ¯”ä¾‹ä»¥å¡«æ»¿æ¡†æ¡† (Cover æ¨¡å¼)
                    const scale = Math.max(photoSize / img.width, photoSize / img.height);
                    
                    imagesData.push({
                        img: img,
                        scale: scale,
                        x: (photoSize - img.width * scale) / 2, // ç½®ä¸­
                        y: (photoSize - img.height * scale) / 2
                    });
                    
                    loaded++;
                    if(loaded === files.length) {
                        filmOffsetX = 220; // é‡ç½®åˆ°åº•ç‰‡æ®¼å£
                        draw();
                    }
                };
            });
        });

        // 2. ç¹ªè£½é‚è¼¯
        function draw() {
            // æ¸…ç©ºç•«é¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const totalFilmWidth = imagesData.length * (photoSize + gap) + 100;

            // å­˜æª”ç‹€æ…‹
            ctx.save();
            
            // --- A. ç¹ªè£½åº•ç‰‡æ®¼ (Canister) - æ°¸é å›ºå®šåœ¨å·¦å´ ---
            // ç‚ºäº†è®“åº•ç‰‡çœ‹èµ·ä¾†æ˜¯å¾ä¸‹é¢ç©¿éå»ï¼Œæˆ‘å€‘å…ˆä¸ç•«æ®¼ï¼Œæœ€å¾Œå†ç•«æ®¼è“‹ä½
            
            // ç§»å‹•åº§æ¨™ç³»ä¾†ç•«è† æ²
            // è† æ²çš„ä½ç½®ç”± filmOffsetX æ±ºå®š
            ctx.translate(filmOffsetX, (canvas.height - filmHeight) / 2);

            // --- B. æŠ•å½±å…‰æšˆ (Glow Layer) - åƒ…åœ¨æŠ•å½±æ¨¡å¼ ---
            if (isProjection) {
                imagesData.forEach((data, i) => {
                    const x = i * (photoSize + gap) + 50;
                    ctx.save();
                    // é€™è£¡ä½¿ç”¨é«˜æ–¯æ¨¡ç³Šä¾†æ¨¡æ“¬å…‰ç·šæŠ•å°„
                    ctx.filter = 'blur(30px)'; 
                    ctx.globalAlpha = 0.6;
                    ctx.globalCompositeOperation = 'lighter'; // å…‰ç·šç–ŠåŠ æ•ˆæœ
                    
                    // ç•«å‡ºæ¨¡ç³Šçš„ç…§ç‰‡ä½œç‚ºèƒŒæ™¯å…‰
                    const w = data.img.width * data.scale;
                    const h = data.img.height * data.scale;
                    
                    // é™åˆ¶å…‰æšˆç¯„åœ
                    ctx.beginPath();
                    ctx.rect(x, padding, photoSize, photoSize);
                    ctx.clip();
                    ctx.drawImage(data.img, x + data.x, padding + data.y, w, h);
                    
                    ctx.restore();
                });
            }

            // --- C. åº•ç‰‡æœ¬é«” ---
            // é»‘è‰²é•·æ¢
            ctx.fillStyle = isProjection ? "rgba(10, 10, 10, 0.85)" : "#111";
            roundRect(ctx, 0, 0, totalFilmWidth, filmHeight, 5, true, false);

            // é½’å­” (Sprockets)
            ctx.fillStyle = "#fff";
            const numHoles = Math.floor(totalFilmWidth / 35);
            for (let k = 0; k < numHoles; k++) {
                const hx = 20 + k * 35;
                // ä¸Šé½’å­”
                roundRect(ctx, hx, 15, 20, 14, 4, true, false);
                // ä¸‹é½’å­”
                roundRect(ctx, hx, filmHeight - 29, 20, 14, 4, true, false);
            }

            // --- D. ç…§ç‰‡ç¹ªè£½ ---
            imagesData.forEach((data, i) => {
                const x = i * (photoSize + gap) + 50;
                
                ctx.save();
                
                // 1. ç•«ç›¸æ¡†å€åŸŸ (Clip Mask)
                ctx.beginPath();
                ctx.rect(x, padding, photoSize, photoSize);
                ctx.clip();

                // 2. è™•ç†æŠ•å½±æ¨¡å¼çš„é€æ˜åº¦
                if (isProjection) {
                    ctx.globalAlpha = 0.8; // ç…§ç‰‡åŠé€æ˜
                    ctx.globalCompositeOperation = 'screen'; // è®“ç…§ç‰‡çœ‹èµ·ä¾†åƒç™¼å…‰çš„è† ç‰‡
                }

                // 3. ç•«åœ– (æ ¹æ“šå€‹åˆ¥çš„ x, y åç§»)
                const w = data.img.width * data.scale;
                const h = data.img.height * data.scale;
                ctx.drawImage(data.img, x + data.x, padding + data.y, w, h);

                // å¦‚æœåœ¨èª¿æ•´æ¨¡å¼ï¼Œç•«å€‹ç´…æ¡†æç¤º
                if (isAdjustMode) {
                    ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, padding, photoSize, photoSize);
                }

                ctx.restore();

                // ç·¨è™Ÿ
                ctx.fillStyle = "#fff";
                ctx.font = "16px Arial";
                ctx.fillText(`${i+1}`, x + photoSize/2 - 5, filmHeight - 10);
                
                // è£é£¾æ€§æ–‡å­—
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.font = "12px Arial";
                ctx.fillText("FUJI RVP", x, 45);
            });

            ctx.restore(); // æ¢å¾©åº§æ¨™ç³»

            // --- E. æœ€å¾Œç¹ªè£½åº•ç‰‡æ®¼ (è“‹åœ¨è† æ²ä¸Šé¢) ---
            drawCanister();

            // è‹¥æ²’æœ‰ç…§ç‰‡çš„æç¤º
            if (imagesData.length === 0) {
                ctx.fillStyle = isProjection ? "#555" : "#aaa";
                ctx.font = "30px Gaegu";
                ctx.textAlign = "center";
                ctx.fillText("Please Upload Photos ğŸ“·", canvas.width/2 + 100, canvas.height/2);
            }
        }

        // ç¹ªè£½åº•ç‰‡æ®¼çš„å‡½å¼
        function drawCanister() {
            const cx = 100; // æ®¼çš„ä½ç½®å›ºå®šåœ¨ç•«é¢å·¦å´
            const cy = (canvas.height - filmHeight) / 2 + filmHeight/2; // å‚ç›´ç½®ä¸­
            const h = filmHeight + 20;
            const w = 80;

            ctx.save();
            // æ®¼èº« (é»ƒè‰²)
            ctx.fillStyle = "#facc15"; 
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 10;
            roundRect(ctx, cx - w/2, cy - h/2, w, h, 5, true, false);
            
            // æ®¼æ¨™ç±¤
            ctx.fillStyle = "#111";
            ctx.fillRect(cx - w/2 + 10, cy - h/2 + 40, w - 20, h - 80);
            
            // æ®¼è“‹å­ (ä¸Šä¸‹é»‘è‰²)
            ctx.fillStyle = "#222";
            // ä¸Šè“‹
            ctx.beginPath();
            ctx.ellipse(cx, cy - h/2, w/2 + 2, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#444"; // å‡¸èµ·
            ctx.beginPath();
            ctx.ellipse(cx, cy - h/2 - 5, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // ä¸‹è“‹
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.ellipse(cx, cy + h/2, w/2 + 2, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // LOGO
            ctx.fillStyle = "#facc15";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 2);
            ctx.fillText("MEMORIES", 0, 5);
            ctx.restore();

            ctx.restore();
        }

        // 3. äº’å‹•é‚è¼¯ (æ ¸å¿ƒä¿®æ”¹)
        container.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
        container.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY));

        window.addEventListener('mousemove', e => onDrag(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => onDrag(e.touches[0].clientX, e.touches[0].clientY));

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        function startDrag(x, y) {
            isDragging = true;
            lastX = x;
            lastY = y;
        }

        function onDrag(x, y) {
            if (!isDragging) return;
            
            const dx = x - lastX;
            const dy = y - lastY;
            lastX = x;
            lastY = y;

            if (isAdjustMode) {
                // --- èª¿æ•´ç…§ç‰‡æ¨¡å¼ ---
                // æ‰¾å‡ºæ»‘é¼ åº•ä¸‹çš„é‚£å¼µç…§ç‰‡
                // æˆ‘å€‘éœ€è¦åæ¨åº§æ¨™ï¼š MouseX -> FilmOffset -> Index
                const relativeX = x - filmOffsetX; 
                // æ¯å€‹å–®ä½å¯¬åº¦
                const unitWidth = photoSize + gap;
                const index = Math.floor((relativeX - 50) / unitWidth);

                if (index >= 0 && index < imagesData.length) {
                    // æ›´æ–°è©²ç…§ç‰‡çš„åç§»é‡
                    const imgData = imagesData[index];
                    imgData.x += dx;
                    imgData.y += dy;
                    // é€™è£¡ä¸åŠ é‚Šç•Œé™åˆ¶ï¼Œè®“ä½¿ç”¨è€…è‡ªç”±æ‹‰ï¼Œæ¯”è¼ƒéˆæ´»
                }
            } else {
                // --- ä¸€èˆ¬æ²å‹•æ¨¡å¼ ---
                filmOffsetX += dx;
                
                // é™åˆ¶ä¸è¦æŠŠåº•ç‰‡å®Œå…¨æ‹‰å‡ºç•«é¢å¤–
                if (filmOffsetX > 300) filmOffsetX = 300; // å·¦é‚Šç•Œ (æ®¼)
            }
            draw();
        }

        function endDrag() {
            isDragging = false;
        }

        // 4. æŒ‰éˆ•åŠŸèƒ½
        const adjustBtn = document.getElementById('adjustBtn');
        adjustBtn.addEventListener('click', () => {
            isAdjustMode = !isAdjustMode;
            adjustBtn.classList.toggle('active');
            container.classList.toggle('editing-mode');
            if(isAdjustMode) {
                statusText.innerText = "ç›´æ¥æ‹–æ›³ç…§ç‰‡èª¿æ•´ä½ç½® / Drag photo inside frame";
                adjustBtn.innerText = "å®Œæˆèª¿æ•´ (Done)";
            } else {
                statusText.innerText = "æ‹–æ›³è† æ² / Drag film strip";
                adjustBtn.innerText = "ğŸ–ï¸ 2. èª¿æ•´ç›¸ç‰‡ä½ç½®";
            }
            draw();
        });

        document.getElementById('toggleMode').addEventListener('click', () => {
            isProjection = !isProjection;
            document.body.classList.toggle('projection-mode');
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            filmOffsetX = 220;
            draw();
        });

        // 5. åŒ¯å‡ºå½±ç‰‡ (ä¿®æ­£é€Ÿåº¦)
        document.getElementById('recordBtn').addEventListener('click', () => {
            if(imagesData.length === 0) return alert("é‚„æ²’ä¸Šå‚³ç…§ç‰‡å–”ï¼");
            
            // å¼·åˆ¶é—œé–‰èª¿æ•´æ¨¡å¼
            isAdjustMode = false;
            adjustBtn.classList.remove('active');
            draw();

            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];
            
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `film_roll_${Date.now()}.webm`;
                a.click();
            };

            // å‹•ç•«è¨­å®š
            filmOffsetX = 300; // å›åˆ°èµ·é»
            const endX = -(imagesData.length * (photoSize + gap)) + canvas.width/2;
            const speed = 2; // é€Ÿåº¦èª¿æ…¢ (åŸæœ¬æ˜¯5)
            
            recorder.start();
            
            function recordLoop() {
                filmOffsetX -= speed;
                draw();
                if (filmOffsetX > endX) {
                    requestAnimationFrame(recordLoop);
                } else {
                    recorder.stop();
                    alert("åŒ¯å‡ºå®Œæˆï¼");
                }
            }
            recordLoop();
        });

        // è¼”åŠ©å½¢ç‹€
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (stroke) ctx.stroke();
            if (fill) ctx.fill();
        }
    </script>
</body>
</html>
